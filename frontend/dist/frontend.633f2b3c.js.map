{"mappings":"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","sources":["js/modules/markdown-parser.js"],"sourcesContent":["/**\r\n * Markdown Parser Module\r\n * Converts markdown to HTML with support for Obsidian-style features\r\n */\r\n\r\nclass MarkdownParser {\r\n    constructor() {\r\n        // Regex patterns for markdown elements\r\n        this.patterns = {\r\n            // Headers\r\n            h1: /^# (.+)$/gm,\r\n            h2: /^## (.+)$/gm,\r\n            h3: /^### (.+)$/gm,\r\n            h4: /^#### (.+)$/gm,\r\n            h5: /^##### (.+)$/gm,\r\n            h6: /^###### (.+)$/gm,\r\n            \r\n            // Text formatting\r\n            bold: /\\*\\*([^*]+)\\*\\*/g,\r\n            italic: /\\*([^*]+)\\*/g,\r\n            boldItalic: /\\*\\*\\*([^*]+)\\*\\*\\*/g,\r\n            strikethrough: /~~([^~]+)~~/g,\r\n            code: /`([^`]+)`/g,\r\n            \r\n            // Links and images\r\n            link: /\\[([^\\]]+)\\]\\(([^)]+)\\)/g,\r\n            image: /!\\[([^\\]]*)\\]\\(([^)]+)\\)/g,\r\n            obsidianImage: /!\\[\\[([^\\]]+)\\]\\]/g,\r\n            \r\n            // Lists\r\n            unorderedList: /^[-*+] (.+)$/gm,\r\n            orderedList: /^\\d+\\. (.+)$/gm,\r\n            \r\n            // Blockquote\r\n            blockquote: /^> (.+)$/gm,\r\n            \r\n            // Horizontal rule\r\n            horizontalRule: /^(-{3,}|_{3,}|\\*{3,})$/gm,\r\n            \r\n            // Code blocks\r\n            codeBlock: /```(\\w*)\\n([\\s\\S]*?)```/g,\r\n            \r\n            // Tables\r\n            tableRow: /^\\|(.+)\\|$/gm,\r\n            tableSeparator: /^\\|[-: ]+\\|$/gm,\r\n            \r\n            // Line breaks\r\n            lineBreak: /  $/gm,\r\n            paragraph: /\\n\\n/g\r\n        };\r\n        \r\n        // Section markers\r\n        this.sectionMarkers = {\r\n            reszletes: /^#+ (Részletes|Detailed|Anatómia|Klinika)/i,\r\n            osszefoglalas: /^#+ (Összefoglalás|Summary|Rövid)/i,\r\n            kepek: /^#+ (Képek|Images|Ábrák|Diagramok|Diagrams)/i\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Parse markdown to HTML\r\n     * @param {string} markdown - The markdown content\r\n     * @returns {Object} - { html: string, sections: Object, toc: Array }\r\n     */\r\n    parseMarkdown(markdown) {\r\n        if (!markdown || typeof markdown !== 'string') {\r\n            throw new ParseError('Invalid markdown input');\r\n        }\r\n        \r\n        try {\r\n            // Extract sections first\r\n            const sections = this.extractSections(markdown);\r\n            \r\n            // Parse each section separately\r\n            const parsedSections = {};\r\n            for (const [key, content] of Object.entries(sections)) {\r\n                parsedSections[key] = this.convertToHTML(content);\r\n            }\r\n            \r\n            // Generate TOC from the detailed section (or full content if no sections)\r\n            const tocContent = sections.reszletes || markdown;\r\n            const toc = this.generateTOC(tocContent);\r\n            \r\n            // Generate full HTML (for backward compatibility)\r\n            const html = this.convertToHTML(markdown);\r\n            \r\n            return {\r\n                html,\r\n                sections: parsedSections,\r\n                toc\r\n            };\r\n        } catch (error) {\r\n            if (error instanceof ParseError) {\r\n                throw error;\r\n            }\r\n            throw new ParseError('Failed to parse markdown', null, markdown);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Extract sections from markdown\r\n     * @private\r\n     */\r\n    extractSections(markdown) {\r\n        const sections = {\r\n            reszletes: '',\r\n            osszefoglalas: '',\r\n            kepek: ''\r\n        };\r\n        \r\n        const lines = markdown.split('\\n');\r\n        let currentSection = 'reszletes'; // Default section\r\n        let sectionContent = [];\r\n        \r\n        for (const line of lines) {\r\n            let sectionFound = false;\r\n            \r\n            // Check if this line marks a new section\r\n            for (const [type, pattern] of Object.entries(this.sectionMarkers)) {\r\n                if (pattern.test(line)) {\r\n                    // Save previous section content\r\n                    if (sectionContent.length > 0) {\r\n                        sections[currentSection] = sectionContent.join('\\n').trim();\r\n                    }\r\n                    \r\n                    // Start new section\r\n                    currentSection = type;\r\n                    sectionContent = [line]; // Include the header\r\n                    sectionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if (!sectionFound) {\r\n                sectionContent.push(line);\r\n            }\r\n        }\r\n        \r\n        // Save last section\r\n        if (sectionContent.length > 0) {\r\n            sections[currentSection] = sectionContent.join('\\n').trim();\r\n        }\r\n        \r\n        // If no sections were found, put everything in részletes\r\n        if (!sections.reszletes && !sections.osszefoglalas && !sections.kepek) {\r\n            sections.reszletes = markdown;\r\n        }\r\n        \r\n        return sections;\r\n    }\r\n    \r\n    /**\r\n     * Convert markdown to HTML\r\n     * @private\r\n     */\r\n    convertToHTML(markdown) {\r\n        let html = markdown;\r\n        \r\n        // Preserve code blocks\r\n        const codeBlocks = [];\r\n        html = html.replace(this.patterns.codeBlock, (match, lang, code) => {\r\n            const placeholder = `___CODEBLOCK_${codeBlocks.length}___`;\r\n            codeBlocks.push({ lang, code });\r\n            return placeholder;\r\n        });\r\n        \r\n        // Preserve inline code\r\n        const inlineCodes = [];\r\n        html = html.replace(this.patterns.code, (match, code) => {\r\n            const placeholder = `___INLINECODE_${inlineCodes.length}___`;\r\n            inlineCodes.push(code);\r\n            return placeholder;\r\n        });\r\n        \r\n        // Convert headers with IDs for navigation\r\n        html = html.replace(this.patterns.h6, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h6 id=\"${id}\">${text}</h6>`;\r\n        });\r\n        html = html.replace(this.patterns.h5, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h5 id=\"${id}\">${text}</h5>`;\r\n        });\r\n        html = html.replace(this.patterns.h4, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h4 id=\"${id}\">${text}</h4>`;\r\n        });\r\n        html = html.replace(this.patterns.h3, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h3 id=\"${id}\">${text}</h3>`;\r\n        });\r\n        html = html.replace(this.patterns.h2, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h2 id=\"${id}\">${text}</h2>`;\r\n        });\r\n        html = html.replace(this.patterns.h1, (match, text) => {\r\n            const id = this.generateId(text);\r\n            return `<h1 id=\"${id}\">${text}</h1>`;\r\n        });\r\n        \r\n        // Convert text formatting (order matters!)\r\n        html = html.replace(this.patterns.boldItalic, '<strong><em>$1</em></strong>');\r\n        html = html.replace(this.patterns.bold, '<strong>$1</strong>');\r\n        html = html.replace(this.patterns.italic, '<em>$1</em>');\r\n        html = html.replace(this.patterns.strikethrough, '<del>$1</del>');\r\n        \r\n        // Convert links and images\r\n        html = html.replace(this.patterns.image, (match, alt, src) => {\r\n            // If it's a local image reference, try to load from images folder\r\n            if (!src.startsWith('http') && !src.startsWith('data:')) {\r\n                // Extract just the filename from the path\r\n                const filename = src.split('/').pop();\r\n                src = `images/${filename}`;\r\n            }\r\n            return `<img src=\"${src}\" alt=\"${alt}\" />`;\r\n        });\r\n        html = html.replace(this.patterns.obsidianImage, (match, filename) => {\r\n            // Convert Obsidian-style image links to images folder\r\n            const imagePath = `images/${filename}`;\r\n            return `<img src=\"${imagePath}\" alt=\"${filename}\" />`;\r\n        });\r\n        html = html.replace(this.patterns.link, '<a href=\"$2\">$1</a>');\r\n        \r\n        // Convert lists\r\n        html = this.convertLists(html);\r\n        \r\n        // Convert blockquotes\r\n        html = html.replace(this.patterns.blockquote, '<blockquote>$1</blockquote>');\r\n        \r\n        // Convert horizontal rules\r\n        html = html.replace(this.patterns.horizontalRule, '<hr />');\r\n        \r\n        // Convert tables\r\n        html = this.convertTables(html);\r\n        \r\n        // Restore code blocks\r\n        codeBlocks.forEach((block, index) => {\r\n            const langClass = block.lang ? ` class=\"language-${block.lang}\"` : '';\r\n            const replacement = `<pre><code${langClass}>${this.escapeHtml(block.code)}</code></pre>`;\r\n            html = html.replace(`___CODEBLOCK_${index}___`, replacement);\r\n        });\r\n        \r\n        // Restore inline code\r\n        inlineCodes.forEach((code, index) => {\r\n            const replacement = `<code>${this.escapeHtml(code)}</code>`;\r\n            html = html.replace(`___INLINECODE_${index}___`, replacement);\r\n        });\r\n        \r\n        // Convert line breaks\r\n        html = html.replace(this.patterns.lineBreak, '<br />');\r\n        \r\n        // Convert paragraphs\r\n        html = this.convertParagraphs(html);\r\n        \r\n        return html;\r\n    }\r\n    \r\n    /**\r\n     * Convert lists to HTML\r\n     * @private\r\n     */\r\n    convertLists(html) {\r\n        const lines = html.split('\\n');\r\n        const result = [];\r\n        let inList = false;\r\n        let listType = null;\r\n        let listItems = [];\r\n        \r\n        for (const line of lines) {\r\n            const unorderedMatch = line.match(/^[-*+] (.+)$/);\r\n            const orderedMatch = line.match(/^\\d+\\. (.+)$/);\r\n            \r\n            if (unorderedMatch || orderedMatch) {\r\n                const item = unorderedMatch ? unorderedMatch[1] : orderedMatch[1];\r\n                const currentType = unorderedMatch ? 'ul' : 'ol';\r\n                \r\n                if (!inList || listType !== currentType) {\r\n                    // Close previous list if any\r\n                    if (inList) {\r\n                        result.push(this.createList(listType, listItems));\r\n                        listItems = [];\r\n                    }\r\n                    inList = true;\r\n                    listType = currentType;\r\n                }\r\n                \r\n                listItems.push(item);\r\n            } else {\r\n                // Not a list item\r\n                if (inList) {\r\n                    result.push(this.createList(listType, listItems));\r\n                    inList = false;\r\n                    listItems = [];\r\n                    listType = null;\r\n                }\r\n                result.push(line);\r\n            }\r\n        }\r\n        \r\n        // Close any remaining list\r\n        if (inList) {\r\n            result.push(this.createList(listType, listItems));\r\n        }\r\n        \r\n        return result.join('\\n');\r\n    }\r\n    \r\n    /**\r\n     * Create HTML list\r\n     * @private\r\n     */\r\n    createList(type, items) {\r\n        const listItems = items.map(item => `<li>${item}</li>`).join('\\n');\r\n        return `<${type}>\\n${listItems}\\n</${type}>`;\r\n    }\r\n    \r\n    /**\r\n     * Convert tables to HTML\r\n     * @private\r\n     */\r\n    convertTables(html) {\r\n        const lines = html.split('\\n');\r\n        const result = [];\r\n        let inTable = false;\r\n        let tableRows = [];\r\n        let headerRow = null;\r\n        \r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            const isTableRow = /^\\|(.+)\\|$/.test(line);\r\n            const isTableSeparator = /^\\|[-: ]+\\|$/.test(line);\r\n            \r\n            if (isTableRow && !isTableSeparator) {\r\n                if (!inTable) {\r\n                    inTable = true;\r\n                    headerRow = line;\r\n                } else {\r\n                    tableRows.push(line);\r\n                }\r\n            } else if (isTableSeparator && inTable && headerRow) {\r\n                // Skip separator, we already have the header\r\n            } else {\r\n                // Not a table row\r\n                if (inTable && headerRow) {\r\n                    result.push(this.createTable(headerRow, tableRows));\r\n                    inTable = false;\r\n                    tableRows = [];\r\n                    headerRow = null;\r\n                }\r\n                result.push(line);\r\n            }\r\n        }\r\n        \r\n        // Close any remaining table\r\n        if (inTable && headerRow) {\r\n            result.push(this.createTable(headerRow, tableRows));\r\n        }\r\n        \r\n        return result.join('\\n');\r\n    }\r\n    \r\n    /**\r\n     * Create HTML table\r\n     * @private\r\n     */\r\n    createTable(headerRow, bodyRows) {\r\n        const parseRow = (row) => {\r\n            return row.split('|')\r\n                .slice(1, -1) // Remove empty first and last elements\r\n                .map(cell => cell.trim());\r\n        };\r\n        \r\n        const headers = parseRow(headerRow);\r\n        const headerHtml = headers.map(h => `<th>${h}</th>`).join('');\r\n        \r\n        const bodyHtml = bodyRows.map(row => {\r\n            const cells = parseRow(row);\r\n            const cellsHtml = cells.map(c => `<td>${c}</td>`).join('');\r\n            return `<tr>${cellsHtml}</tr>`;\r\n        }).join('\\n');\r\n        \r\n        return `<div class=\"table-wrapper\">\r\n<table class=\"markdown-table\">\r\n<thead>\r\n<tr>${headerHtml}</tr>\r\n</thead>\r\n<tbody>\r\n${bodyHtml}\r\n</tbody>\r\n</table>\r\n</div>`;\r\n    }\r\n    \r\n    /**\r\n     * Generate ID from text\r\n     * @private\r\n     */\r\n    generateId(text) {\r\n        // Convert to lowercase, replace spaces with hyphens, remove special chars\r\n        return text.toLowerCase()\r\n            .replace(/[áàäâ]/g, 'a')\r\n            .replace(/[éèëê]/g, 'e')\r\n            .replace(/[íìïî]/g, 'i')\r\n            .replace(/[óòöôő]/g, 'o')\r\n            .replace(/[úùüûű]/g, 'u')\r\n            .replace(/[^a-z0-9\\s-]/g, '')\r\n            .replace(/\\s+/g, '-')\r\n            .replace(/-+/g, '-')\r\n            .trim();\r\n    }\r\n    \r\n    /**\r\n     * Convert paragraphs\r\n     * @private\r\n     */\r\n    convertParagraphs(html) {\r\n        const blocks = html.split('\\n\\n');\r\n        \r\n        return blocks.map(block => {\r\n            block = block.trim();\r\n            if (!block) return '';\r\n            \r\n            // Don't wrap if already wrapped in block element\r\n            if (block.match(/^<(h[1-6]|p|ul|ol|blockquote|pre|table|hr)/)) {\r\n                return block;\r\n            }\r\n            \r\n            return `<p>${block}</p>`;\r\n        }).join('\\n\\n');\r\n    }\r\n    \r\n    /**\r\n     * Generate table of contents\r\n     * @private\r\n     */\r\n    generateTOC(markdown) {\r\n        const toc = [];\r\n        const headerRegex = /^(#{1,6}) (.+)$/gm;\r\n        let match;\r\n        let idCounter = 0;\r\n        \r\n        while ((match = headerRegex.exec(markdown)) !== null) {\r\n            const level = match[1].length;\r\n            const text = match[2];\r\n            const id = this.generateId(text);\r\n            \r\n            toc.push({\r\n                id,\r\n                text,\r\n                level\r\n            });\r\n        }\r\n        \r\n        return this.buildTOCTree(toc);\r\n    }\r\n    \r\n    /**\r\n     * Build hierarchical TOC tree\r\n     * @private\r\n     */\r\n    buildTOCTree(flatToc) {\r\n        const tree = [];\r\n        const stack = [];\r\n        \r\n        for (const item of flatToc) {\r\n            const tocItem = new TocItem({\r\n                id: item.id,\r\n                text: item.text,\r\n                level: item.level\r\n            });\r\n            \r\n            // Find parent\r\n            while (stack.length > 0 && stack[stack.length - 1].level >= item.level) {\r\n                stack.pop();\r\n            }\r\n            \r\n            if (stack.length === 0) {\r\n                tree.push(tocItem);\r\n            } else {\r\n                stack[stack.length - 1].addChild(tocItem);\r\n            }\r\n            \r\n            stack.push(tocItem);\r\n        }\r\n        \r\n        return tree;\r\n    }\r\n    \r\n    /**\r\n     * Escape HTML special characters\r\n     * @private\r\n     */\r\n    escapeHtml(text) {\r\n        const map = {\r\n            '&': '&amp;',\r\n            '<': '&lt;',\r\n            '>': '&gt;',\r\n            '\"': '&quot;',\r\n            \"'\": '&#39;'\r\n        };\r\n        \r\n        return text.replace(/[&<>\"']/g, m => map[m]);\r\n    }\r\n    \r\n    /**\r\n     * Parse sections separately\r\n     */\r\n    parseSections(markdown) {\r\n        const sections = this.extractSections(markdown);\r\n        const result = {};\r\n        \r\n        for (const [type, content] of Object.entries(sections)) {\r\n            if (content) {\r\n                result[type] = Section.fromMarkdown(\r\n                    type,\r\n                    this.getSectionTitle(type),\r\n                    content,\r\n                    this.convertToHTML(content)\r\n                );\r\n            } else {\r\n                result[type] = Section.empty(type, this.getSectionTitle(type));\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Get section title\r\n     * @private\r\n     */\r\n    getSectionTitle(type) {\r\n        const titles = {\r\n            reszletes: 'Részletes',\r\n            osszefoglalas: 'Összefoglalás',\r\n            kepek: 'Képek'\r\n        };\r\n        return titles[type] || type;\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst markdownParser = new MarkdownParser();\r\n\r\n// Export for use in other modules\r\nif (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = { MarkdownParser, markdownParser };\r\n}"],"names":[],"version":3,"file":"frontend.633f2b3c.js.map","sourceRoot":"/__parcel_source_root/"}